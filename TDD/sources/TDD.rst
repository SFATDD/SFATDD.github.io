:title: TDD
:data-transition-duration: 1500
:css: tutorial.css
:skip-help: true

----

TDD
===============

----

:data-y: r1000

“一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。”

----

:data-rotate: 90

目录
====

#. 什么是TDD？
#. 为什么要使用TDD？
#. TDD所使用的技术
#. 什么是UT？
#. 怎么编写测试用例
#. 怎样开始TDD？
#. TDD的原则
#. 测试框架
#. 总结

----


什么是\ **TDD?**
========================

TDD: Test Driven Development

TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。

.. note::
    需求不只是指用户的需求，还包括对代码的使用需求。
    测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。
    通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。
    
----

:data-x: r0
:data-y: r500
:data-scale: 0.1

**Requirements** drive **Tests**

**Tests** drive **Development**

----

:data-x: r-500
:data-scale: 1

* Bob大叔三定律
* FIRST原则
* RGR模式
* 具体化的TDD流程

----

Bob大叔三定律
=============

----

:data-x: r-100
:data-y: r-300
:data-scale: 0.25

定律一
=======

* You are not allowed to write any production code unless it is to make a failing unit test pass.
* 除非为了使一个失败的unit test通过，否则不允许编写任何产品代码。

----

:data-y: r300

定律二
=======

* You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
* 在一个单元测试中只允许编写刚好能够导致失败的内容（编译错误也算失败）。

----

定律三
=======

* You are not allowed to write any more production code than is sufficient to pass the one failing unit test.
* 只允许编写刚好能够使一个失败的unit test通过的产品代码。

----

:data-y: r500
:data-rotate-x: 180

FIRST原则
=========

* **F** ``ast: 测试要非常快，每秒能执行成百上千个``
* **I** ``solated：测试应能够清楚的隔离一个失败``
* **R** ``epeatable：测试应可重复运行，且每次都以同样的方式成功或失败``
* **S** ``elf-verifying：测试要无歧义的表达成功或失败``
* **T** ``imely：频繁、小规模的修改代码``

----

RGR模式
=======

* **R** ed：红色，表示测试失败
* **G** reen: 绿色，表示测试通过
* **R** efactor：重构，优化代码和测试

----

:data-x: r-2500
:data-y: r0
:data-rotate-y: 180
:data-scale: 3

具体化的TDD流程
=================

1. 明确当前要完成的功能，并记录成一个 TODO 列表;
2. 快速完成针对此功能的测试用例编写;
3. 测试代码编译不通过;
4. 编写对应的功能代码;
5. 测试通过;
6. 对代码进行重构，并保证测试通过;
7. 循环完成所有功能的开发。

----

.. image:: images/TDDStep.png
    :height: 600px
    :width: 800px

----

:data-rotate-x: 90
:data-x: r0

为什么要使用\ **TDD?**
========================

* TDD使你的代码100%可测试
* 不用长时间工作在不能运行的代码上
* 你的代码永远是符合设计规格

----

:data-x: r2500

降低bug修正成本
================

.. image:: images/bug.GIF

----

:data-scale: 0.8

TDD的优势
============

* 生产出完全可测试的代码
* 迅速获得可以运行的代码
* 按照规格进行设计，永远不过度设计
* 对代码有信心
* 迅速发现、定位bug
* 可实时验证功能正确性的测试代码就是对代码最好的文档
* 有整套测试用例做基础，通过不断重构很容易添加相关特性

.. note::
    代码是否正确？
    辛苦编写的代码还有没有严重bug？
    修改的新代码对其他部分有没有影响？

----

:data-x: r500

TDD的劣势
==========

* 迫使人们选择一条不同的道路
* 必须严格遵守RGR模式
* 没有获得足够的认可与支持
  
----

:data-x: r800
:data-y: r-800

**TDD** 所使用的技术
========================

* BabyStep
* 重构
* 思维导向编程

----

BabyStep(婴儿步)
=================

* 保证成功率
* 提高信心
* 尽快获得可运行的代码

----

重构
====

* 不断的重构提高代码质量
* 只改变原代码的工作方式而不改变输出
* 有可能导致重大变更
* 包括实现代码及测试代码
* 持续进行
* 被测试用例支持

----

:data-x: r1000
:data-y: r-800

.. image:: images/withoutUT.jpg

----

思维导向编程
=============

* 通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等）
* 对其功能的分解、使用过程、接口都进行了设计
* 提高代码内聚性和复用性

.. note::
    需求不只是指用户的需求，还包括对代码的使用需求

----

:data-scale: 1
:data-x: 0
:data-y: 0
:data-z: 6000
:data-rotate-x: 0
:data-rotate-y: 0
:data-rotate-z: 0

什么是\ **UT?**
========================

* 隔离测试一段代码
* 每次编译自动执行
* 简单明了
* 运行速度快
* 使用模拟对象以避免测试复杂的交互
  
----

:data-x: r-1200

怎么编写测试用例？
========================

1. 使用传统的测试技术
2. 操作过程尽量模拟正常使用的过程
3. 全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖
4. 测试数据尽量包括：真实数据、边界数据
5. 测试语句和测试数据应该尽量简单，容易理解
6. 为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）
7. 如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证

----

怎样开始\ **TDD?**
========================

* 进行一些培训（比如现在）
* 开始一个可以预见的小项目
* 以100%覆盖测试为目标
* 使用RGR开始TDD
* 总结

----

:data-rotate-x: 0

**TDD** 的原则
========================

* 测试隔离
* 一顶帽子
* 测试列表
* 测试驱动
* 先写断言
* 可测试性
* 及时重构
* 进化的测试用例

.. note::
    按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。
    测试也是不断进化的，随着bug的出现，根据bug补齐相关的测试用例即可。
    测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。
    一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。
    测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。
    测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。
    先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。
    可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。
    及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。
    小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）

----

**哪些代码需要测试？**

**跟着感觉走！**

.. note::
    按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。
    对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。

----

单元测试框架
========================
*选择原则：易用，github评星最高*

* java: `JUnit4 <https://github.com/junit-team/junit4>`_ + `mockito <https://github.com/mockito/mockito>`_
* javascript: `Mocha <https://github.com/mochajs/mocha>`_ + `PowerAssert <https://github.com/power-assert-js/power-assert>`_ + `intelli-espower-loader <https://github.com/power-assert-js/intelli-espower-loader>`_
* ObjectiveC: `Kiwi <https://github.com/kiwi-bdd/Kiwi>`_
* C#: `xUnit.net <https://github.com/xunit/xunit>`_



----

总结
========================

* TDD不是所有人的
* TDD是一个非常好的设计原则
* TDD产生100%测试通过的可测试代码
* TDD可以提高软件质量
* 测试不是负担，而是减轻工作量的方法

.. note::
    测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法

----

TDD让你把 **测试** 当作：
=========================

* 验证工具
* 文档工具
* 设计工具

----

遵从下面的 **规则**：
======================

* 迭代进行：将工作拆分成小的步骤
* 总是先写测试代码
* 然后让测试通过
* 最后进行清理——重构

----

最后一点
========

----

It's **fun!**
===============

----

下一步
===============

* Coding Dojo
* 设计原则
* 重构

